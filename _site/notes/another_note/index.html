<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Another_note</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Another_note" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A banana is an edible fruit – botanically a berry – produced by several kinds of large herbaceous flowering plants in the genus Musa." />
<meta property="og:description" content="A banana is an edible fruit – botanically a berry – produced by several kinds of large herbaceous flowering plants in the genus Musa." />
<link rel="canonical" href="http://localhost:4000/notes/another_note/" />
<meta property="og:url" content="http://localhost:4000/notes/another_note/" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-07-08T00:11:06+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Another_note" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-07-08T00:11:06+01:00","datePublished":"2025-07-08T00:11:06+01:00","description":"A banana is an edible fruit – botanically a berry – produced by several kinds of large herbaceous flowering plants in the genus Musa.","headline":"Another_note","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/notes/another_note/"},"url":"http://localhost:4000/notes/another_note/"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body>
    <div class="pagecontents">
        <div class="navbar">
  
    <a href="/">
        HOME
    </a>
  
    <a href="/projects/">
        PROJECTS
    </a>
  
    <a href="/notes/">
        NOTES
    </a>
  
</div>

        <!-- <h1 class="page-title">Another_note</h1> -->
        <div class="container">
            <p>A banana is an edible fruit – botanically a berry – produced by several
kinds of large herbaceous flowering plants in the genus Musa.</p>

<p>In some countries, bananas used for cooking may be called “plantains”,
distinguishing them from dessert bananas. The fruit is variable in size,
color, and firmness, but is usually elongated and curved, with soft
flesh rich in starch covered with a rind, which may be green, yellow,
red, purple, or brown when ripe.</p>

<p><span data-nosnippet="">
<em><a href="/blog/compiling-a-lisp-0/">first</a></em> – <em><a href="/blog/compiling-a-lisp-1/">previous</a></em>
</span></p>

<p>Welcome back to the “Compiling a Lisp” series. Last time we made a small code
execution demo. Today we’re going to add the first part of our language:
integer literals. Our programs will look like this:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">123</code></li>
  <li><code class="language-plaintext highlighter-rouge">-10</code></li>
  <li><code class="language-plaintext highlighter-rouge">0</code></li>
</ul>

<p>But we’re not going to put a parser in. That can come later when it gets harder
to manually construct syntax trees.</p>

<p>Also, since implementing full big number support is pretty tricky, we’re only
going to support fixed-width numbers. It’s entirely possible to then implement
big number support in Lisp after we build out some more features.</p>

<h3 id="pointer-tagging-scheme">Pointer tagging scheme</h3>

<p>Since the integers are always small (less than 64 bits), and we’re targeting
x86-64, we can represent the integers as tagged pointers. To read a little more
about that, check out the “Pointer tagging” section of my <a href="/pl-resources/">Programming
languages resources page</a>. Since we’ll also represent some
other types of objects as tagged pointers, I’ll sketch out a tagging scheme up
front. That way it’s easier to reason about than if I draw it out post-by-post.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>High                                                         Low
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX00  Integer
0000000000000000000000000000000000000000000000000XXXXXXX00001111  Character
00000000000000000000000000000000000000000000000000000000X0011111  Boolean
0000000000000000000000000000000000000000000000000000000000101111  Nil
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX001  Pair
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX010  Vector
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX011  String
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX101  Symbol
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX110  Closure
</code></pre></div></div>

<p>In this diagram, we have some pointer templates composed of <code class="language-plaintext highlighter-rouge">0</code>s, <code class="language-plaintext highlighter-rouge">1</code>s, and
<code class="language-plaintext highlighter-rouge">X</code>s. <code class="language-plaintext highlighter-rouge">0</code> refers to a 0 bit and <code class="language-plaintext highlighter-rouge">1</code> refers to a 1 bit.</p>

<p><code class="language-plaintext highlighter-rouge">X</code> is a placeholder that refers to payload data for that value. For <em>immediate
values</em> — values whose data are part of the pointer itself — the <code class="language-plaintext highlighter-rouge">X</code>s refer
to the data. For heap-allocated objects, it is the pointer address.</p>

<p>It’s important to note that we can only accomplish this tagging scheme because
on modern computer systems the lower 3 bits of heap-allocated pointers are <code class="language-plaintext highlighter-rouge">0</code>
because allocations are <em>word-aligned</em> — meaning that all pointers are
numbers that are multiples of 8. This lets us a) differentiate real pointers
from fake pointers and b) stuff some additional data there in the real
pointers.</p>

<p>These tags let us quickly distinguish objects from one another. Just check the
lower bits:</p>

<ul>
  <li>Lower 2 bits <code class="language-plaintext highlighter-rouge">00</code> means integer</li>
  <li>Lower 3 bits <code class="language-plaintext highlighter-rouge">111</code> means one of the other immediate value types; check the
lower 7 bits to tell them apart</li>
  <li>For any of the other types, there’s a one-to-one mapping of bit pattern in
the lower 3 bits to the type</li>
</ul>

<p>This is a choice that Ghuloum made when drawing up the compiler paper. It’s
entirely possible to pick your own encoding as long as your encoding <em>also</em> has
the property that it’s possible to distinguish the type based on the
pointer.[^1]</p>

<p>We’re going to be a little clever and use the same encoding scheme inside the
compiler to represent Abstract Syntax Tree (AST) nodes as we are going to use
in the compiled code. I mean, why not? We’re going to have to build the
encoding and decoding tools anyway.</p>

<h3 id="pointer-tagging-in-practice">Pointer tagging in practice</h3>

<p>We’ll start off with integer encoding, since we don’t have any other types yet.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="c1">   // for assert</span><span class="cp">
#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="c1">  // for bool</span><span class="cp">
#include</span> <span class="cpf">&lt;stddef.h&gt;</span><span class="c1">   // for NULL</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="c1">   // for int32_t, etc</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="c1">   // for memcpy</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="c1"> // for mmap</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"greatest.h"</span><span class="cp">
</span>
<span class="c1">// Objects</span>

<span class="k">typedef</span> <span class="kt">int64_t</span> <span class="n">word</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">uint64_t</span> <span class="n">uword</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">kBitsPerByte</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>                        <span class="c1">// bits</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">kWordSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>                <span class="c1">// bytes</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">kBitsPerWord</span> <span class="o">=</span> <span class="n">kWordSize</span> <span class="o">*</span> <span class="n">kBitsPerByte</span><span class="p">;</span> <span class="c1">// bits</span>
</code></pre></div></div>

<p>Ignore <code class="language-plaintext highlighter-rouge">greatest.h</code> — that is a header-only library I use for lightweight
testing.</p>

<p><code class="language-plaintext highlighter-rouge">word</code> and <code class="language-plaintext highlighter-rouge">uword</code> are type aliases that I will use throughout the codebase to
refer to types of values that fit in registers. It saves us a bunch of typing
and helps keep types consistent.</p>

<p>To avoid some mysterious magical constants, I’ve also defined helpful names for
the number of bits in a byte (a standard C feature), the number of bytes in a
word, and the number of bits in a word.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kIntegerTag</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kIntegerTagMask</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kIntegerShift</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kIntegerBits</span> <span class="o">=</span> <span class="n">kBitsPerWord</span> <span class="o">-</span> <span class="n">kIntegerShift</span><span class="p">;</span>
<span class="k">const</span> <span class="n">word</span> <span class="n">kIntegerMax</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">kIntegerBits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="n">word</span> <span class="n">kIntegerMin</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1LL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">kIntegerBits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

<span class="n">word</span> <span class="nf">Object_encode_integer</span><span class="p">(</span><span class="n">word</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">kIntegerMax</span> <span class="o">&amp;&amp;</span> <span class="s">"too big"</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">kIntegerMin</span> <span class="o">&amp;&amp;</span> <span class="s">"too small"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">kIntegerShift</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// End Objects</span>
</code></pre></div></div>

<p>As we saw above, integers can be fit inside pointers by shifting them two bits
to the left. We have this handy-dandy function, <code class="language-plaintext highlighter-rouge">Object_encode_integer</code>, for
that.</p>

<p>I’ve added some bounds checks to make sure we don’t accidentally mangle the
values coming in. If the number we’re trying to encode is too big or too small,
shifting it left by 2 bits will chop off the left end.</p>

<p>This function is pretty low-level. It doesn’t add any new type information (it
returns a <code class="language-plaintext highlighter-rouge">word</code>, just as it takes a <code class="language-plaintext highlighter-rouge">word</code>). It’s meant to be a utility
function inside the compiler. We’ll add another function in a moment that
builds on top of this one to make ASTs.</p>

<h3 id="syntax-trees">Syntax trees</h3>

<p>While we could pass around <code class="language-plaintext highlighter-rouge">word</code>s all day and try really hard to keep the
boundary between integral values and pointer values straight, I don’t much
fancy that. I like my type in formation, thank you very much. So we’re going to
add a thin veneer over the object encoding that both gives us some nicer type
APIs and gives the C compiler some hints about when we’ve already encoded an
object.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// AST</span>

<span class="k">struct</span> <span class="n">ASTNode</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ASTNode</span> <span class="n">ASTNode</span><span class="p">;</span>

<span class="n">ASTNode</span> <span class="o">*</span><span class="nf">AST_new_integer</span><span class="p">(</span><span class="n">word</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">ASTNode</span> <span class="o">*</span><span class="p">)</span><span class="n">Object_encode_integer</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">AST_is_integer</span><span class="p">(</span><span class="n">ASTNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">((</span><span class="n">word</span><span class="p">)</span><span class="n">node</span> <span class="o">&amp;</span> <span class="n">kIntegerTagMask</span><span class="p">)</span> <span class="o">==</span> <span class="n">kIntegerTag</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">word</span> <span class="nf">AST_get_integer</span><span class="p">(</span><span class="n">ASTNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="n">node</span> <span class="o">&gt;&gt;</span> <span class="n">kIntegerShift</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// End AST</span>
</code></pre></div></div>

<p>We’ll use these functions pretty heavily in the compiler, especially as we add
more datatypes.</p>

<h3 id="an-expandable-byte-buffer">An expandable byte buffer</h3>

<p>Now that we can manually build programs, let’s get cracking writing our
buffers. We have to emit the machine code to somewhere, after all. Remember the
<code class="language-plaintext highlighter-rouge">mmap</code>/<code class="language-plaintext highlighter-rouge">memcpy</code> stuff from last time? We’re going to wrap those in some
easier-to-remember APIs.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Buffer</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">byte</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">kWritable</span><span class="p">,</span>
  <span class="n">kExecutable</span><span class="p">,</span>
<span class="p">}</span> <span class="n">BufferState</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">byte</span> <span class="o">*</span><span class="n">address</span><span class="p">;</span>
  <span class="n">BufferState</span> <span class="n">state</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">capacity</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Buffer</span><span class="p">;</span>

<span class="n">byte</span> <span class="o">*</span><span class="nf">Buffer_alloc_writable</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">byte</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="cm">/*addr=*/</span><span class="nb">NULL</span><span class="p">,</span> <span class="cm">/*length=*/</span><span class="n">capacity</span><span class="p">,</span>
                      <span class="cm">/*prot=*/</span><span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span>
                      <span class="cm">/*flags=*/</span><span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span>
                      <span class="cm">/*filedes=*/</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="cm">/*offset=*/</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="n">MAP_FAILED</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Buffer_init</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">result</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">Buffer_alloc_writable</span><span class="p">(</span><span class="n">capacity</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">!=</span> <span class="n">MAP_FAILED</span><span class="p">);</span>
  <span class="n">result</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">kWritable</span><span class="p">;</span>
  <span class="n">result</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">result</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Buffer_deinit</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">munmap</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">);</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">Buffer_make_executable</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mprotect</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">PROT_EXEC</span><span class="p">);</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">kExecutable</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>These functions are good building blocks for creating and destroying buffers.
They abstract away some of the fiddly parameters and add runtime checks.</p>

<p>We still need to write into the buffer at some point, though, and we’re not
going to <code class="language-plaintext highlighter-rouge">memcpy</code> whole blocks in. So let’s add some APIs for incremental
writing.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">byte</span> <span class="nf">Buffer_at8</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">Buffer_at_put8</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">byte</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>This <code class="language-plaintext highlighter-rouge">Buffer_at_put8</code> is the building block of the rest of the compiler. Every
write will go through this function. But notice that it is pretty low-level; it
does not do any bounds checks and it does not advance the current position in
the buffer. So let’s add some more functions to do that…</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">word</span> <span class="nf">max</span><span class="p">(</span><span class="n">word</span> <span class="n">left</span><span class="p">,</span> <span class="n">word</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">right</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">Buffer_ensure_capacity</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">word</span> <span class="n">additional_capacity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">additional_capacity</span> <span class="o">&lt;=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">word</span> <span class="n">new_capacity</span> <span class="o">=</span>
      <span class="n">max</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">+</span> <span class="n">additional_capacity</span><span class="p">);</span>
  <span class="n">byte</span> <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="n">Buffer_alloc_writable</span><span class="p">(</span><span class="n">new_capacity</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">munmap</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">"munmap failed"</span><span class="p">);</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">new_capacity</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Buffer_write8</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">byte</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Buffer_ensure_capacity</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">Buffer_at_put8</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Buffer_write32</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span> <span class="n">value</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Buffer_write8</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">kBitsPerByte</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// End Buffer</span>
</code></pre></div></div>

<p>With the addition of <code class="language-plaintext highlighter-rouge">Buffer_ensure_capacity</code>, <code class="language-plaintext highlighter-rouge">Buffer_write8</code>, and
<code class="language-plaintext highlighter-rouge">Buffer_write32</code>, we can start putting together functions to emit x86-64
instructions. I added both <code class="language-plaintext highlighter-rouge">write8</code> and <code class="language-plaintext highlighter-rouge">write32</code> because we’ll need to both
emit single bytes and 32-bit immediate integer values. The helper function
ensures that we don’t need to think about endian-ness every single time we emit
a 32-bit value.</p>

<h3 id="emitting-instructions">Emitting instructions</h3>

<p>There are a couple ways we could write an assembler:</p>

<ul>
  <li>Emit binary directly in the compiler, with comments</li>
  <li>Make a table of all the possible encodings of the instructions we want
(meaning <code class="language-plaintext highlighter-rouge">mov eax, 1</code> and <code class="language-plaintext highlighter-rouge">mov ecx, 1</code> are distinct, for example) and fetch
chunks of bytes from there</li>
  <li>Use some encoding logic to make re-usable building blocks</li>
</ul>

<p>I chose to go with the last option, though I’ve seen all three while looking
for a nice C assembler library. It allows us to write code like
<code class="language-plaintext highlighter-rouge">Emit_mov_reg_imm32(buf, Rcx, 123)</code>, which if you ask me, looks fairly similar
to <code class="language-plaintext highlighter-rouge">mov rcx, 123</code>.</p>

<p>If we were writing C++ we could get really clever with operator overloading…
or we could not.</p>

<p>Note that I did <em>not</em> make up this encoding logic. This is a common phenomenon
in instruction sets and it helps in decoding (for the hardware) and encoding
(for the compilers).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Emit</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">kRax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">kRcx</span><span class="p">,</span>
  <span class="n">kRdx</span><span class="p">,</span>
  <span class="n">kRbx</span><span class="p">,</span>
  <span class="n">kRsp</span><span class="p">,</span>
  <span class="n">kRbp</span><span class="p">,</span>
  <span class="n">kRsi</span><span class="p">,</span>
  <span class="n">kRdi</span><span class="p">,</span>
<span class="p">}</span> <span class="n">Register</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">byte</span> <span class="n">kRexPrefix</span> <span class="o">=</span> <span class="mh">0x48</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Emit_mov_reg_imm32</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">Register</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Buffer_write8</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">kRexPrefix</span><span class="p">);</span>
  <span class="n">Buffer_write8</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xc7</span><span class="p">);</span>
  <span class="n">Buffer_write8</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xc0</span> <span class="o">+</span> <span class="n">dst</span><span class="p">);</span>
  <span class="n">Buffer_write32</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Emit_ret</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span> <span class="n">Buffer_write8</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xc3</span><span class="p">);</span> <span class="p">}</span>

<span class="c1">// End Emit</span>
</code></pre></div></div>

<p>Boom. Two instructions. One <code class="language-plaintext highlighter-rouge">mov</code>, one <code class="language-plaintext highlighter-rouge">ret</code>. The REX prefix is used in x86-64
to denote that the following instruction, which might have been decoded as
something else in x86-32, means something different in 64-bit mode.</p>

<p>In this particular <code class="language-plaintext highlighter-rouge">mov</code>’s case, it is the difference between <code class="language-plaintext highlighter-rouge">mov eax, IMM</code>
and <code class="language-plaintext highlighter-rouge">mov rax, IMM</code>.</p>

<h3 id="compiling-our-first-program">Compiling our first program</h3>

<p>Now that we can emit instructions, it’s time to choose what instructions to
emit based on the input program. We have a very restricted set of input
programs (yes, several billion of them, if you’re being persnickety about the
range of possible integers) so the implementation is short and sweet.</p>

<p>If we see a literal integer, encode it and put it in <code class="language-plaintext highlighter-rouge">rax</code>. Done.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Compile</span>

<span class="kt">int</span> <span class="nf">Compile_expr</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">ASTNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">AST_is_integer</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">word</span> <span class="n">value</span> <span class="o">=</span> <span class="n">AST_get_integer</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">Emit_mov_reg_imm32</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">kRax</span><span class="p">,</span> <span class="n">Object_encode_integer</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">"unexpected node type"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">Compile_function</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">ASTNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Compile_expr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Emit_ret</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// End Compile</span>
</code></pre></div></div>

<p>I make a distinction between <code class="language-plaintext highlighter-rouge">expr</code> and <code class="language-plaintext highlighter-rouge">function</code> because we don’t <em>always</em>
want to <code class="language-plaintext highlighter-rouge">ret</code>. We only want to <code class="language-plaintext highlighter-rouge">ret</code> the result of a function body, which might
be composed of several nested expressions. This divide will become clearer as
we add more expression types.</p>

<h3 id="making-sure-it-works">Making sure it works</h3>

<p>Our compiler is all well and good, but it’s notably more complicated than the
mini JIT demo from the last post. It’s one thing to test <em>that</em> by manually
checking the return code of <code class="language-plaintext highlighter-rouge">main</code>, but I think we should have some regression
tests to keep us honest as we go forth and break things.</p>

<p>For that, I’ve written some testing utilities to help check that we generated
the right code, and also to execute the JITed code and return the result.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">JitFunction</span><span class="p">)();</span>

<span class="c1">// Testing</span>

<span class="cp">#define EXPECT_EQUALS_BYTES(buf, arr)                                          \
  ASSERT_MEM_EQ(arr, (buf)-&gt;address, sizeof arr)
</span>
<span class="n">word</span> <span class="nf">Testing_execute_expr</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">kExecutable</span><span class="p">);</span>
  <span class="c1">// The pointer-pointer cast is allowed but the underlying</span>
  <span class="c1">// data-to-function-pointer back-and-forth is only guaranteed to work on</span>
  <span class="c1">// POSIX systems (because of eg dlsym).</span>
  <span class="n">JitFunction</span> <span class="n">function</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">JitFunction</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">function</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// End Testing</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ASSERT_MEM_EQ</code> will check the generated code and point out any differences if
it finds them. Even though this only prints out hex representations of the
generated code, it’s very helpful. I often paste unexpected output into <code class="language-plaintext highlighter-rouge">rasm2</code>
(part of the radare2 suite), Cutter (also part of the radare2 suite), or <a href="https://defuse.ca/online-x86-assembler.htm">this
online disassembler</a>. If the
instructions look super unfamiliar, it means we messed up the encoding!</p>

<p>Since we have our utilities, we’re going to use the <code class="language-plaintext highlighter-rouge">greatest.h</code> testing API to
write some unit tests for our compiler and compiler utilities.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Tests</span>

<span class="n">TEST</span> <span class="nf">encode_positive_integer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">Object_encode_integer</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mh">0x4</span><span class="p">,</span> <span class="n">Object_encode_integer</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">Object_encode_integer</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
  <span class="n">PASS</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">TEST</span> <span class="nf">encode_negative_integer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="n">Object_encode_integer</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="n">ASSERT_EQ</span><span class="p">((</span><span class="n">word</span><span class="p">)</span><span class="mh">0xfffffffffffffffc</span><span class="p">,</span> <span class="n">Object_encode_integer</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">ASSERT_EQ</span><span class="p">((</span><span class="n">word</span><span class="p">)</span><span class="mh">0xffffffffffffffd8</span><span class="p">,</span> <span class="n">Object_encode_integer</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">));</span>
  <span class="n">PASS</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">TEST</span> <span class="nf">buffer_write8_increases_length</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Buffer</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">Buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Buffer_write8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xdb</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">Buffer_at8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mh">0xdb</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">Buffer_deinit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">PASS</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">TEST</span> <span class="nf">buffer_write8_expands_buffer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Buffer</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">Buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">capacity</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Buffer_write8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xdb</span><span class="p">);</span>
  <span class="n">Buffer_write8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xef</span><span class="p">);</span>
  <span class="n">ASSERT</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">capacity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">Buffer_deinit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">PASS</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">TEST</span> <span class="nf">buffer_write32_expands_buffer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Buffer</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">Buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">capacity</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Buffer_write32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xdeadbeef</span><span class="p">);</span>
  <span class="n">ASSERT</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">capacity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">Buffer_deinit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">PASS</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">TEST</span> <span class="nf">buffer_write32_writes_little_endian</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Buffer</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">Buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">Buffer_write32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xdeadbeef</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">Buffer_at8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mh">0xef</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">Buffer_at8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mh">0xbe</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">Buffer_at8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mh">0xad</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">Buffer_at8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mh">0xde</span><span class="p">);</span>
  <span class="n">Buffer_deinit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">PASS</span><span class="p">();</span>
<span class="p">}</span>


<span class="n">TEST</span> <span class="nf">compile_positive_integer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">word</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
  <span class="n">ASTNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">AST_new_integer</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
  <span class="n">Buffer</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">Buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">compile_result</span> <span class="o">=</span> <span class="n">Compile_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">compile_result</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// mov eax, imm(123); ret</span>
  <span class="n">byte</span> <span class="n">expected</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xc7</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span> <span class="mh">0xec</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xc3</span><span class="p">};</span>
  <span class="n">EXPECT_EQUALS_BYTES</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">expected</span><span class="p">);</span>
  <span class="n">Buffer_make_executable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">word</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Testing_execute_expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Object_encode_integer</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
  <span class="n">PASS</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">TEST</span> <span class="nf">compile_negative_integer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">word</span> <span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">123</span><span class="p">;</span>
  <span class="n">ASTNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">AST_new_integer</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
  <span class="n">Buffer</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">Buffer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">compile_result</span> <span class="o">=</span> <span class="n">Compile_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">compile_result</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// mov eax, imm(-123); ret</span>
  <span class="n">byte</span> <span class="n">expected</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x48</span><span class="p">,</span> <span class="mh">0xc7</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xc3</span><span class="p">};</span>
  <span class="n">EXPECT_EQUALS_BYTES</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="n">expected</span><span class="p">);</span>
  <span class="n">Buffer_make_executable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">word</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Testing_execute_expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Object_encode_integer</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
  <span class="n">PASS</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">SUITE</span><span class="p">(</span><span class="n">object_tests</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">RUN_TEST</span><span class="p">(</span><span class="n">encode_positive_integer</span><span class="p">);</span>
  <span class="n">RUN_TEST</span><span class="p">(</span><span class="n">encode_negative_integer</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SUITE</span><span class="p">(</span><span class="n">buffer_tests</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">RUN_TEST</span><span class="p">(</span><span class="n">buffer_write8_increases_length</span><span class="p">);</span>
  <span class="n">RUN_TEST</span><span class="p">(</span><span class="n">buffer_write8_expands_buffer</span><span class="p">);</span>
  <span class="n">RUN_TEST</span><span class="p">(</span><span class="n">buffer_write32_expands_buffer</span><span class="p">);</span>
  <span class="n">RUN_TEST</span><span class="p">(</span><span class="n">buffer_write32_writes_little_endian</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SUITE</span><span class="p">(</span><span class="n">compiler_tests</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">RUN_TEST</span><span class="p">(</span><span class="n">compile_positive_integer</span><span class="p">);</span>
  <span class="n">RUN_TEST</span><span class="p">(</span><span class="n">compile_negative_integer</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// End Tests</span>

<span class="n">GREATEST_MAIN_DEFS</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GREATEST_MAIN_BEGIN</span><span class="p">();</span>
  <span class="n">RUN_SUITE</span><span class="p">(</span><span class="n">object_tests</span><span class="p">);</span>
  <span class="n">RUN_SUITE</span><span class="p">(</span><span class="n">buffer_tests</span><span class="p">);</span>
  <span class="n">RUN_SUITE</span><span class="p">(</span><span class="n">compiler_tests</span><span class="p">);</span>
  <span class="n">GREATEST_MAIN_END</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>These tests pass, at least for me. And no Valgrind errors, either! The full
source for this post can be put together by putting together the individual
code snippets back to back, in order. I recommend following along and typing it
manually, to get the full educational experience, but if you must copy and
paste it should still work. :)</p>

<p>If you want to convince yourself the tests work, modify the values we’re
checking against in some places. Then you’ll see the test fail. Never trust a
test suite that you haven’t seen fail… it might not be running the tests!</p>

<p>I think there is also a way to use <code class="language-plaintext highlighter-rouge">greatest.h</code> to do setup and teardown so we
don’t have to do all that buffer machinery, but I haven’t figured out an
ergonomic way to do that yet.</p>


        </div>
    </div>
  </body>
</html>

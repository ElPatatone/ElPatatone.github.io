<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Binary in computing</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Binary in computing" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Basics of Binary" />
<meta property="og:description" content="Basics of Binary" />
<link rel="canonical" href="http://localhost:4000/notes/hardware/binary/" />
<meta property="og:url" content="http://localhost:4000/notes/hardware/binary/" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-08-18T16:33:16+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Binary in computing" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-08-18T16:33:16+01:00","datePublished":"2025-08-18T16:33:16+01:00","description":"Basics of Binary","headline":"Binary in computing","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/notes/hardware/binary/"},"url":"http://localhost:4000/notes/hardware/binary/"}</script>
<!-- End Jekyll SEO tag -->

    <script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global',
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

  </head>
  <body>
    <div class="pagecontents">
        <div class="navbar">
  
    <a href="/">
        HOME
    </a>
  
    <a href="/blog/">
        BLOG
    </a>
  
    <a href="/projects/">
        PROJECTS
    </a>
  
    <a href="/notes/">
        NOTES
    </a>
  
</div>

        <!-- <h1 class="page-title">Binary in computing</h1> -->
        <div class="container">
            <h1 class="page-title">Binary in computing</h1>
<h2 id="basics-of-binary">Basics of Binary</h2>

<p>decimal -&gt; base 10
binary -&gt; base 2</p>

<p>binary have <strong>LSB(Least Significant Bit)</strong> and <strong>MSB(Most Significant Bit)</strong></p>

<p>negative numbers in binary can be done with 3 methods:</p>
<ul>
  <li>signed magnitude</li>
  <li>one’s complement</li>
  <li>two’s complement -&gt; method used right now</li>
</ul>

<h2 id="signed-magnitude">Signed Magnitude</h2>
<p>To show the signature of a number in binary, the <strong>MSB</strong> is used as the <strong>sign bit</strong> where
<strong>0</strong> is positive and <strong>1</strong> is negtive.</p>

<p>The rest of the bits are called the <strong>magnitude</strong>.</p>

<p>This is the first method that was used to handle negative numbers but there are 2 
drawbacks:</p>
<ol>
  <li>There are 2 versions for representing the value <strong>0</strong>.</li>
  <li>The arithmetic is messy.</li>
</ol>

<h2 id="ones-complement">One’s Complement</h2>
<p>The <strong>sign bit</strong> is still the <strong>MSB</strong>.</p>

<p>To represent the negative representation of a number, we flip the bits.
Example:<br />
Number 5<br />
Positive binary = 0101<br />
Negative binary = 1010</p>

<p>If there is a carry-out from the MSB, we perform an <strong>end-around carry</strong>, adding the
carry bit back into the LSB.</p>

<p>This solves the issue with arithmetic operations with <strong>one’s complement</strong> but it 
still leaves the issue with the 2 versions of representing the value <strong>0</strong>.</p>

<h2 id="twos-complement">Two’s Complement</h2>
<p>The <strong>sign bit</strong> is still the <strong>MSB</strong>.</p>

<p>To write <strong>-5</strong> we do the following:</p>
<ol>
  <li>Flip the bits -&gt; 5 = 0101 becomes 1010</li>
  <li>Add 1 to the binary number -&gt; 1010 + 1 = 1011 = -5</li>
  <li>During the operation, we can use all the bits without worrying about the sign 
bit, but when we finish we have to remember the sign bit of the original binary 
number and make the decimal value postive or negative based on that.</li>
</ol>

<p>We can prove that the binary <strong>1011</strong> is <strong>-5</strong> the following:</p>
<ol>
  <li>Flip the bits again -&gt; 1011 becomes 0100</li>
  <li>Add 1 to the binary number -&gt; 0100 + 1 = 0101 = 5</li>
</ol>

<p>If there is an extra carry after adding a negative and postive binary number we can 
just ignore it.</p>

<p>This solves the arithmetic issue completely and the <strong>0</strong> problem.</p>

<p>We only use this method if we know that the binary given is a signed value.</p>

<h1 id="binary-in-computing">Binary in Computing</h1>

<p>Computers use <strong>8-bits</strong> values which is <strong>1-byte</strong>.<br />
Binary is used in several ways in computers.</p>

<h2 id="instruction-encoding">Instruction Encoding</h2>

<ul>
  <li>CPU reads instruction as binary (in <strong>.text</strong> section).</li>
  <li>Instruction format varies by ISA (Instruction Set Architecture):
    <ul>
      <li>x86: variable-length (1–15 bytes)</li>
      <li>RISC-V, ARM: fixed-length (e.g., 32 bits)</li>
    </ul>
  </li>
  <li>An instruction can be broken into:
    <ul>
      <li>Opcode (what to do) like:
        <ul>
          <li>ADD = 101</li>
          <li>MOVE = 100</li>
        </ul>
      </li>
      <li>Register specifiers (operands)</li>
      <li>Immediate values</li>
      <li>Addressing mode bits</li>
    </ul>
  </li>
</ul>

<h2 id="memoryram">Memory/RAM</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Memory is **byte-addressable** where each unit is **1-byte** = **8-bits**    
- Each byte has an address associated to it
</code></pre></div></div>

<h2 id="information-from-hardware">Information from hardware</h2>
<p>Hardware like keyboards uses cables that transfer the information of what keys 
are being pressed and that can be seen as bits.</p>

<h2 id="how-does-a-cpu-understand-the-instructions">How does a CPU understand the instructions?</h2>
<p>An instruction is a binary-encoded command to the CPU that consists of:</p>
<ul>
  <li><strong>opcode</strong>: tells the CPU what to do</li>
  <li><strong>operands</strong>: tells the CPU what to do it with</li>
</ul>

<p>We use <strong>decoding</strong> to tell the CPU how to deal with instructions.</p>

<p>Example <strong>opcodes</strong>:</p>

<table>
  <thead>
    <tr>
      <th>Operation</th>
      <th>Binary</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MOVE</td>
      <td>01</td>
    </tr>
    <tr>
      <td>ADD</td>
      <td>10</td>
    </tr>
    <tr>
      <td>HALT</td>
      <td>11</td>
    </tr>
    <tr>
      <td>NO ACTION</td>
      <td>00</td>
    </tr>
  </tbody>
</table>

<p>They will have different components tied together making decisions based on the 
current being passed in.</p>

<p>When the CPU reads an instruction, it extracts the <strong>opcode</strong> and sends it to all
the different <strong>decoders</strong> (subsystems for all the instructions).</p>

<p>When the correct decoder is found then it will trigger its subsystem to carry out the 
operation.</p>

<p>With the following example instruction:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>010111
01 = Opcode for MOVE operation
01 = source address
11 = destination address
</code></pre></div></div>

<p>Once the <strong>MOVE</strong> decoder receives the extracted <strong>opcode</strong>, it will then move the data 
in address <strong>01</strong> to the address <strong>11</strong>.</p>

<p>Good to know:
When we talk about a <strong>64-bit</strong> computer:</p>
<ul>
  <li>how many bits are available for a single memory address.</li>
  <li>the <strong>bus width</strong> which is the amount of wires connecting the different units 
inside a computer.</li>
  <li>the size of <strong>registers</strong> (memory cells inside the CPU) the fastest memory inside
of a computer.</li>
</ul>



        </div>
    </div>
  </body>
</html>
